Checksumming. You can use whatever approach for checksumming you want. Remember that the data, sequence number, ack, checksum, and length fields can all be corrupted (errors in the hardware do not know about our packet structure!). We would suggest a TCP-like checksum, which consists of the sum of the (integer) sequence and ack field values, added to a character-by-character sum of the valid payload field of the packet (i.e., treat each character as if it were an 8 bit integer and just add them together).
Note that any shared "state" among your routines needs to be in the form of global variables. Note also that any information that your procedures need to save from one invocation to the next must also be a global (or static) variable. For example, your routines will need to keep a copy of a packet for possible retransmission. It would probably be a good idea for such a data structure to be a global variable in your code. Note, however, that if one of your global variables is used by your sender side, that variable MUST NOT be accessed by the receiving side entity, since in real life, communicating entities connected only by a communication channel can not share global variables. Violating this rule will result in a low score on this project (as in a 0 or close to 0).
Start simple. Set the probabilities of loss and corruption to zero and test out your routines. Better yet, design and implement your procedures for the case of no loss and no corruption, and get them working first. Then handle the case of one of these probabilities being non-zero, and then finally both being non-zero.